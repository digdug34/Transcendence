<?xml version="1.0" encoding="utf-8"?>

<TranscendenceModule>
	<Globals>
		(block Nil

			(setq rpgAdjustInstallPrice (lambda (theObj theItem thePriceAdj theCurrency)
				(switch
					(isInt thePriceAdj)
						(divide
							(multiply thePriceAdj (itmGetInstallCost theItem theCurrency))
							100
							)

					(isFunction thePriceAdj)
						(apply thePriceAdj theItem Nil)

					(itmGetInstallCost theItem theCurrency)
					)
				))

			(setq rpgAdjustPrice (lambda (theObj theItem thePriceAdj theCurrency noInventoryCheck)
				(switch
					(isInt thePriceAdj)
						(divide
							(multiply thePriceAdj (itmGetPrice theItem theCurrency))
							100
							)

					(isFunction thePriceAdj)
						(apply thePriceAdj theItem Nil)

					(objGetSellPrice theObj theItem noInventoryCheck)
					)
				))

			(setq rpgDockServices (lambda (targetObj options)
				(block Nil
				
					;	For now we only support the player ship
					
					(if (not (eq targetObj gPlayerShip))
						(error "rpgDockServices only support gPlayerShip.")
						)
						
					;	Show the appropriate dock services screen based on the ship
					;	class.
					
					(scrShowScreen gScreen
						(objGetProperty targetObj 'dockServicesScreen)
						options
						)
					)
				))
				
			(setq rpgCalcDockServiceArmorAction (lambda (dockObj shipObj options)
				(block (
					(armorForSale 
						(filter (objGetItems dockObj "aUN") theItemToBuy
							(and (objGetSellPrice dockObj theItemToBuy)
									(objGetArmorReplacePrice dockObj theItemToBuy)
									)
							)
						)
					(armorInCargo (objGetItems shipObj "aU"))
					(armorToInstall
						(filter armorInCargo theItemToInstall
							(block (
								(installStatus (objGetItemProperty dockObj theItemToInstall 'installItemStatus))
								)
								(and (@ installStatus 'canInstall)
									(not (@ installStatus 'upgradeInstallOnly))
									)
								)
							)
						)
						
					(shieldsForSale 
						(filter (objGetItems dockObj "sUN") theItemToBuy
							(and (objGetSellPrice dockObj theItemToBuy)
									(objGetItemProperty dockObj theItemToBuy 'installDevicePrice)
									)
							)
						)
					(shieldsToInstall
						(filter (objGetItems shipObj "sU") theItemToInstall
							(block (
								(installStatus (objGetItemProperty dockObj theItemToInstall 'installDeviceStatus))
								)
								(and (@ installStatus 'canInstall)
									(not (@ installStatus 'upgradeInstallOnly))
									)
								)
							)
						)
						
					(maxArmorLevel (map armorForSale 'reduceMax theItemToBuy (itmGetLevel theItemToBuy)))
					(maxShieldsLevel (map shieldsForSale 'reduceMax theItemToBuy (itmGetLevel theItemToBuy)))
					(maxRepairArmorLevel (objGetProperty dockObj 'repairArmorMaxLevel))
					
					(minPlayerArmorLevel (map (objGetItems shipObj "aI") 'reduceMin theItemToUpgrade (itmGetLevel theItemToUpgrade)))
					(minPlayerShieldsLevel (map (objGetItems shipObj "sI") 'reduceMin theItemToUpgrade (itmGetLevel theItemToUpgrade)))
					)
					
					(switch
						(= dockObj shipObj)
							{
								visible: True
								enabled: True
								desc: (or (scrTranslate gScreen "actionArmor:shipConfig")
										(typTranslate &dsRPGDockServicesBase; "actionArmor:shipConfig")
										)
								}
								
						;	If we have upgrades
						
						(and armorForSale
								(geq maxArmorLevel minPlayerArmorLevel)
								)
							{
								visible: True
								enabled: True
								desc: (or (objTranslate dockObj "dockServices:armorAbility" { items:armorForSale maxLevel:maxArmorLevel })
										(scrTranslate gScreen "actionArmor:defaultArmorUpgrade" { items:armorForSale maxLevel:maxArmorLevel })
										(typTranslate &dsRPGDockServicesBase; "actionArmor:defaultArmorUpgrade" { items:armorForSale maxLevel:maxArmorLevel })
										)
								}
						
						(and shieldsForSale
								(geq maxShieldsLevel minPlayerShieldsLevel)
								)
							{
								visible: True
								enabled: True
								desc: (or (objTranslate dockObj "dockServices:shieldsAbility" { items:shieldsForSale maxLevel:maxShieldsLevel })
										(scrTranslate gScreen "actionArmor:defaultShieldsUpgrade" { items:shieldsForSale maxLevel:maxShieldsLevel })
										(typTranslate &dsRPGDockServicesBase; "actionArmor:defaultShieldsUpgrade" { items:shieldsForSale maxLevel:maxShieldsLevel })
										)
								}
						
						;	If we can install something for the player
						
						armorToInstall
							{
								visible: True
								enabled: True
								desc: (or (scrTranslate gScreen "actionArmor:defaultArmorInstall" { items:armorToInstall maxLevel:(objGetProperty dockObj 'installArmorMaxLevel) })
										(typTranslate &dsRPGDockServicesBase; "actionArmor:defaultArmorInstall" { items:armorToInstall maxLevel:(objGetProperty dockObj 'installArmorMaxLevel) })
										)
								}
								
						shieldsToInstall
							{
								visible: True
								enabled: True
								desc: (or (scrTranslate gScreen "actionArmor:defaultShieldsInstall" { items:shieldsToInstall maxLevel:(objGetProperty dockObj 'installDeviceMaxLevel) })
										(typTranslate &dsRPGDockServicesBase; "actionArmor:defaultShieldsInstall" { items:shieldsToInstall maxLevel:(objGetProperty dockObj 'installDeviceMaxLevel) })
										)
								}
								
						;	Can we repair the player's armor?
						
						(geq maxRepairArmorLevel minPlayerArmorLevel)
							{
								visible: True
								enabled: True
								desc: (or (scrTranslate gScreen "actionArmor:defaultArmorRepair" { maxLevel:maxRepairArmorLevel })
										(typTranslate &dsRPGDockServicesBase; "actionArmor:defaultArmorRepair" { maxLevel:maxRepairArmorLevel })
										)
								}
								
						maxRepairArmorLevel
							{
								visible: True
								enabled: Nil
								desc: (or (scrTranslate gScreen "actionArmor:noTechToRepair" { maxLevel:maxRepairArmorLevel })
										(typTranslate &dsRPGDockServicesBase; "actionArmor:noTechToRepair" { maxLevel:maxRepairArmorLevel })
										)
								}
								
						;	Otherwise, nothing
						
						{
							visible: True
							enabled: Nil
							desc: (or (scrTranslate gScreen "actionArmor:nothing")
									(typTranslate &dsRPGDockServicesBase; "actionArmor:nothing")
									)
							}
						)
					)
				))
			
			(setq rpgCalcDockServiceBuyAmmo (lambda (dockObj shipObj theItem options)
				(switch
					(= dockObj shipObj)
						{
							visible: Nil
							}
							
					;	If this item does not require ammo, then we hide the action
					
					(not (itmGetProperty theItem 'ammoType))
						{
							visible: Nil
							}
							
					;	If the station doesn't have any ammo to sell, then we disabled and
					;	explain.
					
					(not (filter (objGetItems dockObj (cat "m +launchedBy:" (itmGetType theItem) ";")) theItemToBuy
							(objGetSellPrice dockObj theItemToBuy)
							))
						{
							visible: True
							enabled: Nil
							desc: 
								(if (= (@ options 'category) 'launcher)
									(or (scrTranslate gScreen "actionBuyAmmo.noMissilesToBuy" { item:theItem }) (scrTranslate gScreen "actionBuyMissiles:noMissilesToBuy" { item:theItem }))
									(or (scrTranslate gScreen "actionBuyAmmo.noAmmoToBuy" { item:theItem }) (scrTranslate gScreen "actionBuyAmmo:noAmmoToBuy" { item:theItem }))
									)
							}
							
					;	Otherwise, we do have some
					
					{
						visible: True
						enabled: True
						desc:
							(if (= (@ options 'category) 'launcher)
								(or (scrTranslate gScreen "actionBuyAmmo.missilesForSale" { item:theItem }) (scrTranslate gScreen "actionBuyMissiles:missilesForSale" { item:theItem }))
								(or (scrTranslate gScreen "actionBuyAmmo.ammoForSale" { item:theItem }) (scrTranslate gScreen "actionBuyAmmo:ammoForSale" { item:theItem }))
								)
						}
					)
				))
				
			(setq rpgCalcDockServiceInstallAction (lambda (dockObj shipObj options)
				(block (
					allItems
					)
					(switch
						(= dockObj shipObj)
							{
								visible: Nil
								}
								
						;	If we cannot install items, then we omit this option. We will show the
						;	proper error in Upgrade
						
						(not (objGetProperty dockObj 'installDeviceMaxLevel))
							{
								visible: Nil
								}
				
						;	If the station only installs as part of upgrade, then say so.

						(objGetProperty dockObj 'installDeviceUpgradeOnly)
							{
								visible: True
								enabled: Nil
								desc: (scrTranslate gScreen "actionInstall:upgradeInstallOnly" { category:(@ options 'category) })
								}
							
						;	If no items to install, action is disabled
					
						(not (setq allItems (objGetItems shipObj (@ options 'criteria))))
							{
								visible: True
								enabled: Nil
								desc: (scrTranslate gScreen "actionInstall:noItemInCargo" { category:(@ options 'category) })
								}
								
						;	If none of the items can be installed because of compatibility, then
						;	say so.
						
						(not (filter allItems theItemToInstall
								(!= (@ (objCanInstallItem shipObj theItemToInstall) 1) 'notCompatible)
								))
							{
								visible: True
								enabled: Nil
								desc: (or
										(objTranslate shipObj 'rpg.noCompatibleDeviceInCargo { category:(@ options 'category) })
										(scrTranslate gScreen "actionInstall:noCompatibleItemInCargo" { category:(@ options 'category) })
										)
								}
							
						;	We might be able to install something

						{
							visible: True
							enabled: True
							desc: (or (objTranslate dockObj "dockServices:installAbility" { category:(@ options 'category) })
									(scrTranslate gScreen "actionInstall:defaultAbility" { category:(@ options 'category) dockObj:dockObj })
									)
							}
						)
					)
				))
				
			(setq rpgCalcDockServiceMiscDevicesAction (lambda (dockObj shipObj options)
				(block (
					(itemsForSale 
						(filter (objGetItems dockObj "d~wsUN") theItemToBuy
							(and (objGetSellPrice dockObj theItemToBuy)
									(objGetItemProperty dockObj theItemToBuy 'installDevicePrice)
									(!= (@ (objCanInstallItem shipObj theItemToBuy) 1) 'notCompatible)
									)
							)
						)
					(itemsToInstall
						(filter (objGetItems shipObj "d~wsU") theItemToInstall
							(block (
								(installStatus (objGetItemProperty dockObj theItemToInstall 'installDeviceStatus))
								)
								(and (@ installStatus 'canInstall)
									(not (@ installStatus 'upgradeInstallOnly))
									)
								)
							)
						)
					(itemsToRemove
						(filter (objGetItems shipObj "d~wsrI") theItemToRemove
							(block (
								(removeStatus (objGetItemProperty dockObj theItemToRemove 'removeItemStatus))
								)
								(and (@ removeStatus 'canRemove)
									(not (@ removeStatus 'upgradeInstallOnly))
									)
								)
							)
						)
						
					(maxLevel (map itemsForSale 'reduceMax theItemToBuy (itmGetLevel theItemToBuy)))
					)
					
					(switch
						(= dockObj shipObj)
							{
								visible: True
								enabled: True
								desc: (scrTranslate gScreen "actionMiscDevices:shipConfig")
								}
								
						;	If we have upgrades
						
						itemsForSale
							{
								visible: True
								enabled: True
								desc: (or (objTranslate dockObj "dockServices:miscDevicesAbility" { items:itemsForSale maxLevel:maxLevel })
										(scrTranslate gScreen "actionMiscDevices:defaultUpgrade" { items:itemsForSale maxLevel:maxLevel })
										)
								}
						
						;	If we can install something for the player
						
						itemsToInstall
							{
								visible: True
								enabled: True
								desc: (scrTranslate gScreen "actionMiscDevices:defaultInstall" { items:itemsToInstall maxLevel:(objGetProperty dockObj 'installDeviceMaxLevel) })
								}
								
						;	If we can remove something for the player
						
						itemsToRemove
							{
								visible: True
								enabled: True
								desc: (scrTranslate gScreen "actionMiscDevices:defaultRemove" { items:itemsToRemove maxLevel:(objGetProperty dockObj 'installDeviceMaxLevel) })
								}
								
						;	Otherwise, nothing
						
						{
							visible: True
							enabled: Nil
							desc: (scrTranslate gScreen "actionMiscDevices:nothing")
							}
						)
					)
				))
				
			(setq rpgCalcDockServiceRefuelAction (lambda (dockObj shipObj options)
				(block (
					(currencyUsed (objGetDefaultCurrency dockObj))
					(fuelToUse (objGetRefuelItemAndPrice dockObj shipObj))
					(fuelItem (@ fuelToUse 0))
					(cost (@ fuelToUse 1))
					(maxCount (if fuelToUse (shpGetFuelNeeded shipObj fuelItem) 0))
					(maxAfford (if (gr cost 0) (divide (objGetBalance shipObj currencyUsed) cost) 0))
					)
					
					(switch
						(= dockObj shipObj)
							{
								visible: Nil
								}
								
						(not (objGetProperty dockObj 'refuelMaxLevel))
							{
								visible: True
								enabled: Nil
								desc: (or (scrTranslate gScreen "actionRefuel:noRefuel")
										(typTranslate &dsRPGDockServicesBase; "actionRefuel:noRefuel")
										)
								}
								
						(not fuelToUse)
							{
								visible: True
								enabled: Nil
								desc: (or (scrTranslate gScreen "actionRefuel:noCompatibleFuel")
										(typTranslate &dsRPGDockServicesBase; "actionRefuel:noCompatibleFuel")
										)
								}
								
						(and (= cost 0) (= maxCount 0))
							{
								visible: True
								enabled: Nil
								desc: (or (scrTranslate gScreen "actionRefuel:freeRefuel" { item:fuelItem needed:maxCount })
										(typTranslate &dsRPGDockServicesBase; "actionRefuel:freeRefuel" { item:fuelItem needed:maxCount })
										)
								}
								
						(= cost 0)
							{
								visible: True
								enabled: True
								desc: (or (scrTranslate gScreen "actionRefuel:freeRefuel" { item:fuelItem needed:maxCount })
										(typTranslate &dsRPGDockServicesBase; "actionRefuel:freeRefuel" { item:fuelItem needed:maxCount })
										)
								
								fuelItem: fuelItem
								cost: cost
								maxCount: maxCount
								maxAfford: maxAfford
								maxNeeded: maxCount
								}
								
						(= maxCount 0)
							{
								visible: True
								enabled: Nil
								desc: (or (scrTranslate gScreen "actionRefuel:noFuelNeeded" { item:fuelItem })
										(typTranslate &dsRPGDockServicesBase; "actionRefuel:noFuelNeeded" { item:fuelItem })
										)
								}
								
						(= maxAfford 0)
							{
								visible: True
								enabled: Nil
								desc: (or (scrTranslate gScreen "actionRefuel:cantAfford" { item:fuelItem cost:(fmtCurrency currencyUsed cost) needed:maxCount afford:maxAfford })
										(typTranslate &dsRPGDockServicesBase; "actionRefuel:cantAfford" { item:fuelItem cost:(fmtCurrency currencyUsed cost) needed:maxCount afford:maxAfford })
										)
								}
								
						(ls maxAfford maxCount)
							{
								visible: True
								enabled: True
								desc: (or (scrTranslate gScreen "actionRefuel:cantAfford" { item:fuelItem cost:(fmtCurrency currencyUsed cost) needed:maxCount afford:maxAfford })
										(typTranslate &dsRPGDockServicesBase; "actionRefuel:cantAfford" { item:fuelItem cost:(fmtCurrency currencyUsed cost) needed:maxCount afford:maxAfford })
										)
								
								fuelItem: fuelItem
								cost: cost
								maxCount: maxAfford
								maxAfford: maxAfford
								maxNeeded: maxCount
								}
								
						{
							visible: True
							enabled: True
							desc: (or (scrTranslate gScreen "actionRefuel:refuel" { item:fuelItem cost:(fmtCurrency currencyUsed cost) needed:maxCount })
									(typTranslate &dsRPGDockServicesBase; "actionRefuel:refuel" { item:fuelItem cost:(fmtCurrency currencyUsed cost) needed:maxCount })
									)
								
							fuelItem: fuelItem
							cost: cost
							maxCount: maxCount
							maxAfford: maxAfford
							maxNeeded: maxCount
							}
						)
					)
				))
				
			(setq rpgCalcDockServiceRemoveAction (lambda (dockObj shipObj theItem options)
				(switch
					(= dockObj shipObj)
						{
							visible: Nil
							}
							
					;	For devices, excluding reactors
					
					(itmMatches theItem "d~rI")
						(block (
							(currencyUsed (objGetDefaultCurrency dockObj))
							(itemStatus (shpCanRemoveDevice shipObj theItem))
							(dockStatus (objGetItemProperty dockObj theItem 'removeItemStatus))
							(costToRemove (@ dockStatus 'price))
							)
							
							(switch
								;	If we cannot remove devices, then say so.
						
								(not (objGetProperty dockObj 'removeDeviceMaxLevel))
									{
										visible: True
										enabled: Nil
										desc: (scrTranslate gScreen 'actionInstall.noDeviceRemove { item:theItem })
										}
										
								(@ dockStatus 'upgradeInstallOnly)
									{
										visible: Nil	;	The Replace action already shows the message, so no need to repeat
										enabled: Nil
										desc: (scrTranslate gScreen "actionRemove:upgradeInstallOnly" { item:theItem })
										}
										
								(not (@ dockStatus 'canRemove))
									{
										visible: True
										enabled: Nil
										desc: (scrTranslate gScreen "actionRemove:noTech" { item:theItem })
										}
										
								(not (isint itemStatus))
									{
										visible: True
										enabled: Nil
										desc: itemStatus
										}
										
								(= itemStatus 1)
									{
										visible: True
										enabled: Nil
										desc: (scrTranslate gScreen "actionRemove.noRoomForCargoHold" { item:theItem })
										}
								
								(not (eq itemStatus 0))
									{
										visible: True
										enabled: Nil
										desc: (scrTranslate gScreen "actionRemove:cannotRemove" { item:theItem })
										}
								
								(gr (itmGetMass theItem) (objGetCargoSpaceLeft shipObj))
									{
										visible: True
										enabled: Nil
										desc: (scrTranslate gScreen "actionRemove:noRoomInCargo")
										}
								
								(ls (objGetBalance shipObj currencyUsed) costToRemove)
									{
										visible: True
										enabled: Nil
										desc: (scrTranslate gScreen "actionRemove:cannotAfford" { cost:(fmtCurrency currencyUsed costToRemove) })
										cost: costToRemove
										}
								
								(eq costToRemove 0)
									{
										visible: True
										enabled: True
										desc: (scrTranslate gScreen "actionRemove:freeRemove")
										cost: 0
										}

								{
									visible: True
									enabled: True
									desc: (scrTranslate gScreen "actionRemove:remove" { cost:(fmtCurrency currencyUsed costToRemove) })
									cost: costToRemove
									}
								)
							
							)
				
					;	Otherwise, not supported
					
					{
						visible: Nil
						}
					)
				))
				
			(setq rpgCalcDockServiceRepairAction (lambda (dockObj shipObj theItem options)
				(switch
					(= dockObj shipObj)
						{
							visible: Nil
							}
				
					;	If armor segment...
					
					(= (itmGetProperty theItem 'category) 'armor)
						(block (
							(damage (objGetArmorDamage shipObj theItem))
							(maxHP (shpGetArmorMaxHitPoints shipObj theItem))
							(currencyUsed (objGetDefaultCurrency dockObj))
							(costToRepair (objGetArmorRepairPrice dockObj shipObj theItem damage))
							(armorNoun (cat (objGetArmorName shipObj theItem) " " (itmGetName theItem 0x20)))
							)
							
							(switch
								(eq damage 0)
									{
										visible: True
										enabled: Nil
										desc: (typTranslate &dsRPGManageArmor; 'descArmorNotDamaged { armorNoun:armorNoun })
										}

								(gr (itmGetProperty theItem 'repairLevel) (objGetProperty dockObj 'repairArmorMaxLevel))
									{
										visible: True
										enabled: Nil
										desc: (typTranslate &dsRPGManageArmor; 'descArmorNoTech { armorNoun:armorNoun })
										}
										
								(not costToRepair)
									{
										visible: True
										enabled: Nil
										desc: (typTranslate &dsRPGManageArmor; 'descArmorCantRepair { armorNoun:armorNoun })
										}

								(ls (objGetBalance shipObj currencyUsed) costToRepair)
									{
										visible: True
										enabled: Nil
										desc: (typTranslate &dsRPGManageArmor; 'descArmorCantAfford { armorNoun:armorNoun cost:(fmtCurrency currencyUsed costToRepair) })
										cost: costToRepair
										}

								(eq costToRepair 0)
									{
										visible: True
										enabled: True
										desc: (typTranslate &dsRPGManageArmor; 'descArmorFreeRepair { armorNoun:armorNoun })
										cost: 0
										}

								{
									visible: True
									enabled: True
									desc: (typTranslate &dsRPGManageArmor; 'descArmorRepair { armorNoun:armorNoun cost:(fmtCurrency currencyUsed costToRepair) })
									cost: costToRepair
									}
								)
							)
							
					;	Otherwise, not supported
					
					{
						visible: Nil
						}
					)
				))
				
			(setq rpgCalcDockServiceReplaceAction (lambda (dockObj shipObj theItem options)
				(switch
					(= dockObj shipObj)
						{
							visible: Nil
							}
				
					;	For armor
					
					(itmMatches theItem "aI")
						(block (
							(itemsAvail 
								(filter (objGetItems shipObj (@ options 'criteria)) theItemInCargo
									(not (itmIsEqual theItemInCargo theItem 'ignoreInstalled))
									)
								)
							(maxLevel (map itemsAvail 'reduceMax theItemInCargo (itmGetLevel theItemInCargo)))
							)
							
							(switch
								(not itemsAvail)
									{
										visible: True
										enabled: Nil
										desc: (scrTranslate gScreen "actionReplace:noItemInCargo" { category:(@ options 'category) item:theItem })
										}
										
								(ls maxLevel (itmGetLevel theItem))
									{
										visible: True
										enabled: True
										desc: (or (objTranslate dockObj "dockServices:installAbility" { category:(@ options 'category) maxLevel:maxLevel })
												(scrTranslate gScreen "actionReplace:defaultAbility" { category:(@ options 'category) dockObj:dockObj maxLevel:maxLevel })
												)
										}
										
								{
									visible: True
									enabled: True
									desc: (or (objTranslate dockObj "dockServices:installAbility" { category:(@ options 'category) })
											(scrTranslate gScreen "actionReplace:defaultAbility" { category:(@ options 'category) dockObj:dockObj })
											)
									}
								)
							)
							
					;	For all devices
					
					(itmMatches theItem "dI")
						(block (
							(itemsAvail 
								(filter (objGetItems shipObj (@ options 'criteria)) theItemInCargo
									(not (itmIsEqual theItemInCargo theItem 'ignoreInstalled))
									)
								)
							(maxLevel (map itemsAvail 'reduceMax theItemInCargo (itmGetLevel theItemInCargo)))
						
							(currencyUsed (objGetDefaultCurrency dockObj))
							(itemStatus (shpCanRemoveDevice shipObj theItem))
							(dockStatus (objGetItemProperty dockObj theItem 'removeItemStatus))
							)
							
							(switch
								;	If we cannot install items, then we omit this option. We will show the
								;	proper error in Upgrade
						
								(not (objGetProperty dockObj 'installDeviceMaxLevel))
									{
										visible: Nil
										}
							
								(not (isint itemStatus))
									{
										;	If we cannot be removed, then the Remove action will show the error,
										;	unless it's a reactor, in which case we have to show it here (because
										;	Remove action never shows reactors).
										
										visible: (itmMatches theItem "r")
										enabled: Nil
										desc: itemStatus
										}
								
								(not (eq itemStatus 0))
									{
										;	If we cannot be removed, then the Remove action will show the error,
										;	unless it's a reactor, in which case we have to show it here (because
										;	Remove action never shows reactors).
										
										visible: (itmMatches theItem "r")
										enabled: Nil
										desc: (scrTranslate gScreen "actionReplace:cannotReplace" { item:theItem })
										}
								
								(@ dockStatus 'upgradeInstallOnly)
									{
										visible: True
										enabled: Nil
										desc: (scrTranslate gScreen "actionReplace:upgradeInstallOnly" { item:theItem })
										}
										
								(not itemsAvail)
									{
										visible: True
										enabled: Nil
										desc: (scrTranslate gScreen "actionReplace:noItemInCargo" { category:(@ options 'category) })
										}
								
								(not (@ dockStatus 'canRemove))
									{
										visible: True
										enabled: Nil
										desc: (scrTranslate gScreen "actionReplace:noTech" { item:theItem })
										}
										
								(ls maxLevel (itmGetLevel theItem))
									{
										visible: True
										enabled: True
										desc: (or (objTranslate dockObj "dockServices:installAbility" { category:(@ options 'category) maxLevel:maxLevel })
												(scrTranslate gScreen "actionReplace:defaultAbility" { category:(@ options 'category) dockObj:dockObj maxLevel:maxLevel })
												)
										}
										
								{
									visible: True
									enabled: True
									desc: (or (objTranslate dockObj "dockServices:installAbility" { category:(@ options 'category) })
											(scrTranslate gScreen "actionReplace:defaultAbility" { category:(@ options 'category) dockObj:dockObj })
											)
									}
								)
							
							)
				
					;	Otherwise, not supported
					
					{
						visible: Nil
						}
					)
				))
				
			(setq rpgCalcDockServiceUpgradeAction (lambda (dockObj shipObj theItem options)
				(switch
					(= dockObj shipObj)
						{
							visible: Nil
							}
				
					;	For installing a new device
					
					(and (not theItem) (!= (@ options 'category) 'armor))
						(block (
							(itemsForSale 
								(filter (objGetItems dockObj (@ options 'criteria)) theItemToBuy
									(and (objGetSellPrice dockObj theItemToBuy)
											(objGetItemProperty dockObj theItemToBuy 'installDevicePrice)
											(!= (@ (objCanInstallItem shipObj theItemToBuy) 1) 'notCompatible)
											)
									)
								)
							(maxLevel (map itemsForSale 'reduceMax theItem (itmGetLevel theItem)))
							)
							
							(switch
								;	If we cannot install items, then say so.
						
								(not (objGetProperty dockObj 'installDeviceMaxLevel))
									{
										visible: True
										enabled: Nil
										desc: (scrTranslate gScreen 'actionInstall.noDeviceInstall { category:(@ options 'category) })
										}
				
								(not itemsForSale)
									{
										visible: True
										enabled: Nil
										desc: (or (scrTranslate gScreen "actionUpgrade.noItemForSale" { category:(@ options 'category) }) 
                                                (scrTranslate gScreen "actionUpgrade:noItemForSale" { category:(@ options 'category) })
                                                )
										}
					
								{
									visible: True
									enabled: True
									desc: (or (objTranslate dockObj "dockServices:upgradeAbility" { category:(@ options 'category) maxLevel:maxLevel })
                                            (scrTranslate gScreen "actionUpgrade.defaultAbility" { category:(@ options 'category) dockObj:dockObj maxLevel:maxLevel })
											(scrTranslate gScreen "actionUpgrade:defaultAbility" { category:(@ options 'category) dockObj:dockObj maxLevel:maxLevel })
											)
									}
								)
							)
				
					;	For armor
					
					(itmMatches theItem "aI")
						(block (
							(itemsForSale 
								(filter (objGetItems dockObj (@ options 'criteria)) theItemToBuy
									(and (objGetSellPrice dockObj theItemToBuy)
											(objGetArmorReplacePrice dockObj theItemToBuy)
											(!= (@ (objCanInstallItem shipObj theItemToBuy) 1) 'notCompatible)
											)
									)
								)
							(maxLevel (map itemsForSale 'reduceMax theItemToBuy (itmGetLevel theItemToBuy)))
							(maxLevelUpgrade
								(map itemsForSale 'reduceMax theItemToBuy 
									(if (not (itmIsEqual theItemToBuy theItem 'ignoreInstalled))
										(itmGetLevel theItemToBuy)
										0
										)
									)
								)
							)
							
							(switch
								(not itemsForSale)
									{
										visible: True
										enabled: Nil
										desc: (or (scrTranslate gScreen "actionUpgrade.noItemForSale" { category:(@ options 'category) })
                                                (scrTranslate gScreen "actionUpgrade:noItemForSale" { category:(@ options 'category) })
                                                )
										}
										
								(ls maxLevelUpgrade (itmGetLevel theItem))
									{
										visible: True
										enabled: Nil
										desc: (or (scrTranslate gScreen "actionUpgrade.noItemUpgrade" { category:(@ options 'category) item:theItem })
                                                (scrTranslate gScreen "actionUpgrade:noItemUpgrade" { category:(@ options 'category) item:theItem })
                                                )
										}
					
								{
									visible: True
									enabled: True
									desc: (or (objTranslate dockObj "dockServices:upgradeAbility" { category:(@ options 'category) maxLevel:maxLevel })
                                            (scrTranslate gScreen "actionUpgrade.defaultAbility" { category:(@ options 'category) dockObj:dockObj maxLevel:maxLevel })
											(scrTranslate gScreen "actionUpgrade:defaultAbility" { category:(@ options 'category) dockObj:dockObj maxLevel:maxLevel })
											)
									}
								)
							)
							
					;	For all devices (except miscellaneous devices)
					
					(and (itmMatches theItem "dI")
							(!= (@ options 'category) 'device)
							)
						(block (
							(itemsForSale 
								(filter (objGetItems dockObj (@ options 'criteria)) theItemToBuy
									(and (objGetSellPrice dockObj theItemToBuy)
											(objGetItemProperty dockObj theItemToBuy 'installDevicePrice)
											(!= (@ (objCanInstallItem shipObj theItemToBuy) 1) 'notCompatible)
											)
									)
								)
							(maxLevel (map itemsForSale 'reduceMax theItemToBuy (itmGetLevel theItemToBuy)))
							(maxLevelUpgrade
								(map itemsForSale 'reduceMax theItemToBuy 
									(if (not (itmIsEqual theItemToBuy theItem 'ignoreInstalled))
										(itmGetLevel theItemToBuy)
										0
										)
									)
								)
						
							(currencyUsed (objGetDefaultCurrency dockObj))
							(itemStatus (shpCanRemoveDevice shipObj theItem))
							(dockStatus (objGetItemProperty dockObj theItem 'removeItemStatus))
							)
							
							(switch
								;	If we cannot install items, then say so.
						
								(not (objGetProperty dockObj 'installDeviceMaxLevel))
									{
										visible: True
										enabled: Nil
										desc: (scrTranslate gScreen 'actionInstall.noDeviceInstall { category:(@ options 'category) })
										}
				
								(not (isint itemStatus))
									{
										visible: (@ dockStatus 'upgradeInstallOnly)	;	If we cannot be removed, then the Remove action will show the error
										enabled: Nil
										desc: itemStatus
										}
								
								(= itemStatus 1)
									{
										visible: (@ dockStatus 'upgradeInstallOnly)	;	If we cannot be removed, then the Remove action will show the error
										enabled: Nil
										desc: (scrTranslate gScreen "actionRemove.noRoomForCargoHold" { item:theItem })
										}
								
								(not (eq itemStatus 0))
									{
										visible: (@ dockStatus 'upgradeInstallOnly)	;	If we cannot be removed, then the Remove action will show the error
										enabled: Nil
										desc: (or (scrTranslate gScreen "actionReplace.cannotReplace" { item:theItem })
                                                (scrTranslate gScreen "actionReplace:cannotReplace" { item:theItem })
                                                )
										}
								
								(not itemsForSale)
									{
										visible: True
										enabled: Nil
										desc: (or (scrTranslate gScreen "actionUpgrade.noItemForSale" { category:(@ options 'category) })
                                                (scrTranslate gScreen "actionUpgrade:noItemForSale" { category:(@ options 'category) })
                                                )
										}
								
								(ls maxLevelUpgrade (itmGetLevel theItem))
									{
										visible: True
										enabled: Nil
										desc: (or (scrTranslate gScreen "actionUpgrade.noItemUpgrade" { category:(@ options 'category) item:theItem })
                                                (scrTranslate gScreen "actionUpgrade:noItemUpgrade" { category:(@ options 'category) item:theItem })
                                                )
										}
										
								(not (@ dockStatus 'canRemove))
									{
										visible: True
										enabled: Nil
										desc: (or (scrTranslate gScreen "actionUpgrade.noTech" { item:theItem })
                                                (scrTranslate gScreen "actionUpgrade:noTech" { item:theItem })
                                                )
										}
										
								(not (isint itemStatus))
									{
										visible: True
										enabled: Nil
										desc: itemStatus
										}
								
								(not (eq itemStatus 0))
									{
										visible: True
										enabled: Nil
										desc: (or (scrTranslate gScreen "actionUpgrade.cannotUpgrade" { item:theItem })
                                                (scrTranslate gScreen "actionUpgrade:cannotUpgrade" { item:theItem })
                                                )
										}
								
								{
									visible: True
									enabled: True
									desc: (or (objTranslate dockObj "dockServices:upgradeAbility" { category:(@ options 'category) maxLevel:maxLevel })
                                            (scrTranslate gScreen "actionUpgrade.defaultAbility" { category:(@ options 'category) dockObj:dockObj maxLevel:maxLevel })
											(scrTranslate gScreen "actionUpgrade:defaultAbility" { category:(@ options 'category) dockObj:dockObj maxLevel:maxLevel })
											)
									}
								)
							
							)
				
					;	Otherwise, not supported
					
					{
						visible: Nil
						}
					)
				))
				
			(setq rpgCalcDockServiceWeaponsAction (lambda (dockObj shipObj options)
				(block (
					(itemsForSale 
						(filter (objGetItems dockObj "wUN") theItemToBuy
							(and (objGetSellPrice dockObj theItemToBuy)
									(objGetItemProperty dockObj theItemToBuy 'installDevicePrice)
									(!= (@ (objCanInstallItem shipObj theItemToBuy) 1) 'notCompatible)
									)
							)
						)
					(itemsToInstall
						(filter (objGetItems shipObj "wU") theItemToInstall
							(block (
								(installStatus (objGetItemProperty dockObj theItemToInstall 'installDeviceStatus))
								)
								(and (@ installStatus 'canInstall)
									(not (@ installStatus 'upgradeInstallOnly))
									)
								)
							)
						)
					(itemsToRemove
						(filter (objGetItems shipObj "wI") theItemToRemove
							(block (
								(removeStatus (objGetItemProperty dockObj theItemToRemove 'removeItemStatus))
								)
								(and (@ removeStatus 'canRemove)
									(not (@ removeStatus 'upgradeInstallOnly))
									)
								)
							)
						)
					(ammoWeapons (filter (objGetItems shipObj "wI") theItem
						(itmGetProperty theItem 'ammoType)
						))
					(ammoForSale
						(filter (objGetItems dockObj "m") theItem
							(and
								(objGetSellPrice dockObj theItem)
								(filter ammoWeapons theWeapon
									(itmMatches theItem (cat "m +launchedBy:" (itmGetType theWeapon) ";"))
									)
								)
							)
						)
						
					(maxLevel (map itemsForSale 'reduceMax theItemToBuy (itmGetLevel theItemToBuy)))
					(minPlayerLevel (map (objGetItems shipObj "wI") 'reduceMin theItemToUpgrade (itmGetLevel theItemToUpgrade)))
					)
					
					(switch
						(= dockObj shipObj)
							{
								visible: True
								enabled: True
								desc: (scrTranslate gScreen "actionWeapons:shipConfig")
								}
								
						;	If we have upgrades
						
						(and itemsForSale
								(geq maxLevel minPlayerLevel)
								)
							{
								visible: True
								enabled: True
								desc: (or (objTranslate dockObj "dockServices:weaponsAbility" { items:itemsForSale maxLevel:maxLevel })
										(scrTranslate gScreen "actionWeapons:defaultUpgrade" { items:itemsForSale maxLevel:maxLevel })
										)
								}
						
						;	If we can install something for the player
						
						itemsToInstall
							{
								visible: True
								enabled: True
								desc: (or (objTranslate dockObj "dockServices:installAbility" { items:itemsToInstall maxLevel:(objGetProperty dockObj 'installDeviceMaxLevel) })
										(scrTranslate gScreen "actionWeapons:defaultInstall" { items:itemsToInstall maxLevel:(objGetProperty dockObj 'installDeviceMaxLevel) })
										)
								}
								
						;	If we can sell ammo
						
						ammoForSale
							{
								visible: True
								enabled: True
								desc: (scrTranslate gScreen "actionWeapons:defaultAmmo" { items:ammoForSale maxLevel:(map ammoForSale 'reduceMax theItem (itmGetLevel theItem)) })
								}
								
						;	If we can remove items
						
						itemsToRemove
							{
								visible: True
								enabled: True
								desc: (or (objTranslate dockObj "dockServices:installAbility" { items:itemsToRemove maxLevel:(objGetProperty dockObj 'installDeviceMaxLevel) })
										(scrTranslate gScreen "actionWeapons:defaultRemove" { items:itemsToRemove maxLevel:(objGetProperty dockObj 'installDeviceMaxLevel) })
										)
								}
								
						;	No upgrades for player
						
						itemsForSale
							{
								visible: True
								enabled: Nil
								desc: (scrTranslate gScreen "actionWeapons:noBetterUpgrades" { maxLevel:maxLevel })
								}
								
						;	Otherwise, nothing
						
						{
							visible: True
							enabled: Nil
							desc: (scrTranslate gScreen "actionWeapons:nothing")
							}
						)
					)
				))
				
			(setq rpgCalcReactorRefuelAction (lambda (dockObj shipObj theItem options)
				(block (
					fuelItems
					bestFuel
					)
					
					(switch
						;	If not a reactor, then this doesn't apply
						
						(not (itmMatches theItem "rI"))
							{
								visible: Nil
								}
								
						;	If not the player ship, then we call the normal refuel code
						
						(!= dockObj shipObj)
							(rpgCalcDockServiceRefuelAction dockObj shipObj {})
							
						;	If the player has no fuel items, then we can't refuel
						
						(not (setq fuelItems (objGetItems shipObj "f")))
							{
								visible: True
								enabled: Nil
								desc: (or (scrTranslate gScreen "actionRefuel:noFuelInCargo")
										(typTranslate &dsRPGDockServicesBase; "actionRefuel:noFuelInCargo")
										)
								}
								
						;	If none of the fuel items are compatible, then we can't refuel.

						(not (setq bestFuel (map fuelItems (list 'original 'reduceMin 'excludeNil) theFuel
								(if (shpIsFuelCompatible shipObj theFuel)
									(itmGetProperty theFuel 'fuelCapacity)
									)
								)))
							{
								visible: True
								enabled: Nil
								desc: (or (scrTranslate gScreen "actionRefuel:noCompatibleFuelInCargo")
										(typTranslate &dsRPGDockServicesBase; "actionRefuel:noCompatibleFuelInCargo")
										)
								}
								
						;	If we're already full, no need for fuel
						
						(= (shpGetFuelNeeded shipObj bestFuel) 0)
							{
								visible: True
								enabled: Nil
								desc: (or (scrTranslate gScreen "actionRefuel:noFuelNeeded")
										(typTranslate &dsRPGDockServicesBase; "actionRefuel:noFuelNeeded")
										)
								}
								
						;	Otherwise, we can refuel from cargo
						
						{
							visible: True
							enabled: True
							desc: (or (scrTranslate gScreen "actionRefuel:refuelFromCargo")
									(typTranslate &dsRPGDockServicesBase; "actionRefuel:refuelFromCargo")
									)
							}
						)
					)
				))
			
			;	rpgCalcToHit
			;
			;	This is a generic function useful for calculating probability of
			;	something happending when you have an attack value and a defense
			;	value.
			;
			;	attack and defense must both be between 0 and 100. The result is
			;	a probability of success from 0 to 100.
			;
			;	See: https://forums.kronosaur.com/viewtopic.php?p=63206#p63206
				
			(setq rpgCalcToHit (lambda (attack defense)
				(switch
					(leq attack 0)
						0
						
					(leq defense 0)
						attack
						
					(divide (* attack attack) (+ attack defense))
					)
				))
				
			;	rpgDestroyItems
			;
			;	This function is used to destroy items on a station when the station
			;	is destroyed. This avoids having too much loot in friendly stations,
			;	and thus reduces the temptation to attack them.
			
			(setq rpgDestroyItems (lambda (theObj)
				(block (allItems remainingItems)
					(setq allItems (objGetItems theObj "*U"))

					; Generate a list of the items that are left
					(setq remainingItems Nil)
					(enum allItems theItem
						(block (damagedItemCount undamgedItemCount)
							(setq undamagedItemCount 0)
							(setq damagedItemCount 0)
							(switch
								; 70% of devices and armor are destroyed
								; 20% are damaged
								; 10% are OK
								(itmMatches theItem "ad")
									(block (tenth tenthMod)
										(setq tenth (divide (itmGetCount theItem) 10))
										(setq tenthMod (modulo (itmGetCount theItem) 10))

										(setq undamagedItemCount (add undamagedItemCount tenth (if (leq (random 1 10) tenthMod) 1 0)))
										(setq damagedItemCount (add damagedItemCount tenth (if (leq (random 1 10) tenthMod) 1 0) tenth (if (leq (random 1 10) tenthMod) 1 0)))
										)

								; 70% of other items are destroyed
								(block Nil
									(setq undamagedItemCount (divide (multiply 30 (itmGetCount theItem)) 100))
									)
								)

							; Add to our list
							(if (gr damagedItemCount 0)
								(setq remainingItems (append remainingItems (list (itmSetCount (itmSetDamaged theItem) damagedItemCount))))
								)

							(if (gr undamagedItemCount 0)
								(setq remainingItems (append remainingItems (list (itmSetCount theItem undamagedItemCount))))
								)

							; Remove from object
							(objRemoveItem theObj theItem)
							)
						)

					; Add back remaining items
					(enum remainingItems theItem
						(objAddItem theObj theItem)
						)
					)
				))

			;	rpgGetInstallerList
			;
			;	Returns a list of objects that are able to install the given item
			;	on the given ship. The objects are returned in a list sorted
			;	by distance to the ship.
			
			(setq rpgGetInstallerList (lambda (theShip theItem)
				(filter (sysFindObject theShip "TAF +populated; S:d") theObj
					(block (
						(installStatus (objGetItemProperty theObj theItem 'installDeviceStatus))
						)
													
						(and (@ installStatus 'canInstall)
							(not (@ installStatus 'upgradeInstallOnly))
							)
						)
					)
				))

			(setq rpgGetReactorUpgradeList (lambda (theObj theShip theCriteria)
				(block (minPower reactorList additionalList)

					; Compute the current reactor power of the player ship
					; NOTE: We have to multiply by 100 to get to kilowatts
					(setq minPower (multiply (objGetMaxPower theShip) 100))

					; Make a list of reactor items, filtering out any that are
					; too small for the ship.
					(setq reactorList (map (itmGetTypes theCriteria) 'excludeNil theUNID
						(switch

							; If this reactor has less power than the player's
							; current reactor, then skip it.
							(leq (typGetDataField theUNID 'power) minPower)
								Nil

							; Not if the object wouldn't normally sell it
							(not (objGetSellPrice theObj (itmCreate theUNID 1) 'noInventoryCheck))
								Nil

							; Otherwise, add the reactor to the list
							(itmCreate theUNID 1)
							)
						))

					; Append any reactors that the object happens to have. But 
					; make sure that we don't duplicate.
					(setq additionalList (map (objGetItems theObj "rNU") 'excludeNil theItem
						(switch
							; Not if we already have it in our list
							(find reactorList (itmSetCount theItem 1))
								Nil

							; If this reactor has less power than the player's
							; current reactor, then skip it.
							(leq (typGetDataField (itmGetType theItem) 'power) minPower)
								Nil

							; Not if the object wouldn't normally sell it
							(not (objGetSellPrice theObj theItem 'noInventoryCheck))
								Nil

							; Add it
							theItem
							)
						))

					; Return the list
					(append reactorList additionalList)
					)
				))

			(setq rpgInitScreenSet (lambda (screenSet)
                (block (
                    (curFrame (scrGetScreen gScreen))
                    (curScreen (@ curFrame 'screen))
                    
                    (curScreenIndex Nil)
                    (curScreenDesc Nil)
                    )
                    ;   Find the index of our screen in the screen set
                    
                    (for i 0 (- (count screenSet) 1)
                        (if (= (@ (@ screenSet i) 'screen) curScreen)
                            (setq curScreenIndex i)
                            )
                        )
                        
                    (setq curScreenDesc (@ screenSet curScreenIndex))
                        
                    ;   If we have a screen before, show that in page up
                    
                    (if (and curScreenIndex (geq curScreenIndex 1))
                        (block (
                            (buttonDesc (@ screenSet (- curScreenIndex 1)))
                            (screen (@ buttonDesc 'screen))
                            (screenData (struct (@ buttonDesc 'data) { screenSet:screenSet }))
                            )
                            (if (@ buttonDesc 'mainScreen)
                                (scrAddMinorAction gScreen "ScreenSetNav_Up" Nil (cat "[PageUp] " (@ buttonDesc 'label))
    					            (scrExitScreen gScreen)
                                    )
                                (scrAddMinorAction gScreen "ScreenSetNav_Up" Nil (cat "[PageUp] " (@ buttonDesc 'label))
                                    (lambda ()
                                        (block ()
							                (scrExitScreen gScreen)
							                (scrShowScreen gScreen screen screenData)
                                            )
                                        )
                                    )
                                )
                            )
                        )
                        
                    ;   If we have a screen after, show that in page down
                    
                    (if (and curScreenIndex (ls curScreenIndex (- (count screenSet) 1)))
                        (block (
                            (buttonDesc (@ screenSet (+ curScreenIndex 1)))
                            (screen (@ buttonDesc 'screen))
                            (screenData (struct (@ buttonDesc 'data) { screenSet:screenSet }))
                            )
                            (if (@ curScreenDesc 'mainScreen)
                                (scrAddMinorAction gScreen "ScreenSetNav_Down" Nil (cat "[PageDown] " (@ buttonDesc 'label))
                                    (lambda ()
						                (scrShowScreen gScreen screen screenData)
                                        )
                                    )
                                (scrAddMinorAction gScreen "ScreenSetNav_Down" Nil (cat "[PageDown] " (@ buttonDesc 'label))
                                    (lambda ()
                                        (block ()
							                (scrExitScreen gScreen)
							                (scrShowScreen gScreen screen screenData)
                                            )
                                        )
                                    )
                                )
                            )
                        )
                        
                    ;   Add button to exit
                    
                    (switch
                        ;   If no screen set, then just add a normal done button
                        
                        (not screenSet)
                            (scrAddAction gScreen 'actionDone Nil "" (scrExitScreen gScreen))
                            
                        ;   If we're on the root/main screen then we only need a single exit
                        
                        (@ curScreenDesc 'mainScreen)
                            (scrAddMinorAction gScreen "ScreenSetNav_Exit" Nil "[Escape] Done"
    					        (scrExitScreen gScreen)
                                )
                                
                        ;   Otherwise, we need a double exit
                        
                        (scrAddMinorAction gScreen "ScreenSetNav_Exit" Nil "[Escape] Done"
                            (block ()
							    (scrExitScreen gScreen)
                                
                                ;   Double-exit because we want to leave the main dock screen
                                ;   also.
                                
							    (scrExitScreen gScreen)
                                )
                            )
                        )
                    )
                ))
            
			(setq rpgInstallDevicePrep (lambda (data)

				; Data must have the following fields
				;
				;	item:					The item to install
				;
				; In addition, the following optional fields are supported
				;
				;	buyAndInstall:			If True, we're installing as part of purchase
				;	checkMilitaryID:		If True, we check for military ID, if necessary
				;	checkTotalPower:		If True, we fail unless the total power of all devices matches reactor output
				;	currencyUsed:			The currency used
				;	installerObj:			Object installing the device (if Nil, we assume a station)
				;	installPriceAdj:		Installation price (only if totalPrice is Nil)
				;	itemInCargo:			If True, item is in player's cargo hold
				;	maxTechLevel:			The maximum tech level we will install (unless we match techCriteriaOverride)
				;	noCargoCheck:			If True, then we don't check to see if the old device fits in cargo
				;	replaceItem:			If not Nil, we try to replace this device.
				;	targetObj:				Object on which to install (if Nil, we assume player ship)
				;	techCriteria:			If not Nil, the item must match this criteria
				;	techCriteriaOverride:	If not Nil, and item matches this criteria, install even if above maxTechLevel
				;	totalPrice:				The total price to install (includes purchase price if buyAndInstall is True)
				;	upgrade:				If True, we are buying an item as an upgrade
				;
				; We return a struct with the following elements:
				;
				;	canInstall:				True if installation can proceed
				;	price:					Total installation cost
				;	desc:					Description of installation attempt

				(block (totalCost desc descWarning

					(thisItem (@ data 'item))
					(targetObj (if (@ data 'targetObj) (@ data 'targetObj) gPlayerShip))
					(installerObj (if (@ data 'installerObj) (@ data 'installerObj) gSource))
					(currencyUsed (if (@ data 'currencyUsed) (@ data 'currencyUsed) (objGetDefaultCurrency installerObj)))
					(itemName (itmGetName thisItem 0x04))
					(canInstall Nil)

					;	If the target object is not the player's ship, then we need to modify
					;	some text
					(textYourShip (if (= targetObj gPlayerShip) "your ship" (cat "the " (objGetName targetObj 0x00))))
					(textWe (if (= installerObj gPlayerShip) "you" "we"))
					(textYour (if (= targetObj gPlayerShip) "your" "the"))
					)

					(if thisItem
						(block (
							;	We use installDeviceStatus instead of installItemStatus because we
							;	don't want to install armor objects.

							(status (objGetItemProperty installerObj thisItem 'installDeviceStatus))
							(itemPrice
								(if (or (@ data 'upgrade) (@ data 'buyAndInstall))
									(objGetSellPrice installerObj thisItem)
									0
									)
								)
							(recommendedSlot
								(switch
									(not (@ data 'replaceItem))
										-1

									(not (itmGetInstallPos (@ data 'replaceItem)))
										-1

									(itmGetInstallPos (@ data 'replaceItem))
									)
								)
							cargoNeeded itemToReplace resultMessage resultCode returnValue stationCannotInstall removeStatus
							installText installTextData
							)

							;	Check if the station can install the device
							
							(switch
								; If tech criteria provided then use them for check
								
								(or (@ data 'maxTechLevel) (@ data 'techCriteria))
									(setq stationCannotInstall (or
										;	If we don't match the tech criteria then we don't have the
										;	technology to install.
										(and (@ data 'techCriteria) (not (itmMatches thisItem (@ data 'techCriteria))))

										;	If our max tech level is too low for the item, then we can't install
										;	(except for specific items that we know about)
										(and (gr (itmGetLevel thisItem) (or (@ data 'maxTechLevel) 30))
											(or (not (@ data 'techCriteriaOverride))
												(not (itmMatches thisItem (@ data 'techCriteriaOverride)))
												)
											)
										))
										
								;	If the installer is the player ship, and it doesn't define
								;	and installation limits, then just allow everything. (This means
								;	that callers are responsible for setting limits. E.g., the Auton
								;	Bay handles this.)
								
								(and (= installerObj gPlayerShip) (not (objGetProperty installerObj 'installDeviceMaxLevel)))
									(setq stationCannotInstall Nil)
									
								;	If we have totalPrice or installPriceAdj AND we're a previous version, then
								;	we always allow an install (even if no TradeDesc). We need this for backwards
								;	compatibility.
								
								(and (ls (getAPIVersion) 31)
										(or (@ data 'totalPrice) (@ data 'installPriceAdj))
										)
									(block Nil
										(dbgOutput "API: " (getAPIVersion))
										(setq stationCannotInstall Nil)
										)

								;	Otherwise result depends on installDeviceStatus property
								(setq stationCannotInstall (not (@ status 'canInstall)))
								)

							;	Compute the cost to install

							(switch
								(@ data 'totalPrice)
									(setq totalCost (@ data 'totalPrice))

								(@ data 'installPriceAdj)
									(setq totalCost (rpgAdjustInstallPrice Nil thisItem (@ data 'installPriceAdj) currencyUsed))

								(@ status 'canInstall)
									(setq totalCost	(add (@ status 'price) itemPrice))

								;	If we get this far, then we cannot install

								(block Nil
									(setq totalCost 0)
									(setq stationCannotInstall True)
									)
								)

							;	Ask the object if we can install the item

							(setq returnValue (objCanInstallItem targetObj thisItem recommendedSlot))
							(setq resultCode (@ returnValue 1))
							(setq resultMessage (@ returnValue 2))
							(setq itemToReplace (@ returnValue 3))

							(switch
								;	If not installable at this station, then ignore

								stationCannotInstall
									(if (@ status 'descID)
										(setq desc (objTranslate installerObj (@ status 'descID) { item:thisItem targetObj:targetObj }))
										(setq desc (or
											(objTranslate installerObj 'rpg.noTechToInstallDevice { item:thisItem targetObj:targetObj })
											(scrTranslate gScreen 'rpg.noTechToInstallDevice { item:thisItem targetObj:targetObj })
											(cat (strCapitalize textWe) " do not have the technology to install " itemName " on " textYourShip ".")
											))
										)

								;   If we exceed the station's tech

								(and (not totalCost)
									(gr (itmGetLevel thisItem) (objGetProperty installerObj 'installDeviceMaxLevel))
									)
									(setq desc (or
										(objTranslate installerObj 'rpg.noTechToInstallDevice { item:thisItem targetObj:targetObj })
										(scrTranslate gScreen 'rpg.noTechToInstallDevice { item:thisItem targetObj:targetObj })
										(cat (strCapitalize textWe) " do not have the technology to install " itemName " on " textYourShip ".")
										))


								(not totalCost)
									(setq desc (or
										(objTranslate installerObj 'rpg.cannotInstallDevice { item:thisItem targetObj:targetObj })
										(scrTranslate gScreen 'rpg.cannotInstallDevice { item:thisItem targetObj:targetObj })
										(cat (strCapitalize textWe) " cannot install " itemName " on " textYourShip ".")
										))

								;	Some stations only install an item if you purchase it from them.

								(and (@ status 'upgradeInstallOnly)
										(not (@ data 'upgrade))
										)
									(setq desc (or
										(objTranslate installerObj 'rpg.cannotInstallDeviceWithoutUpgrade { item:thisItem targetObj:targetObj })
										(scrTranslate gScreen 'rpg.cannotInstallDeviceWithoutUpgrade { item:thisItem targetObj:targetObj })
										(cat "Sorry, installation services are only available for purchased upgrades.")
										))

								;	Check military ID

								(and (@ data 'checkMilitaryID)
										(itmHasAttribute thisItem "Military")
										(not (objGetItems targetObj "*+MilitaryID"))
										)
									(setq desc (or
										(objTranslate installerObj 'rpg.cannotInstallDeviceWithoutMilitaryID { item:thisItem targetObj:targetObj })
										(scrTranslate gScreen 'rpg.cannotInstallDeviceWithoutMilitaryID { item:thisItem targetObj:targetObj })
										(cat "You must have a military ID to use " itemName ".")
										))

								(and (@ data 'checkMilitaryID)
										(itmHasAttribute thisItem "Illegal")
										)
									(setq desc (or
										(objTranslate installerObj 'rpg.cannotInstallDeviceBecauseIllegal { item:thisItem targetObj:targetObj })
										(scrTranslate gScreen 'rpg.cannotInstallDeviceBecauseIllegal { item:thisItem targetObj:targetObj })
										"We do not install illegal items."
										))

								(eq resultCode 'cannotInstall)
									(setq desc resultMessage)
									
								(eq resultCode 'notCompatible)
									(setq desc (or 
										(objTranslate installerObj 'rpg.cannotInstallDeviceBecauseNotCompatible { item:thisItem targetObj:targetObj })
										(scrTranslate gScreen 'rpg.cannotInstallDeviceBecauseNotCompatible { item:thisItem targetObj:targetObj })
										"This device is not compatible with your ship."
										))

								(eq resultCode 'noDeviceSlotsLeft)
									(setq desc (or
										(objTranslate installerObj 'rpg.cannotInstallDeviceBecauseLackOfSlots { item:thisItem targetObj:targetObj slotsRequired:(itmGetProperty thisItem 'deviceSlots) })
										(scrTranslate gScreen 'rpg.cannotInstallDeviceBecauseLackOfSlots { item:thisItem targetObj:targetObj slotsRequired:(itmGetProperty thisItem 'deviceSlots) })
										(if (gr (itmGetProperty thisItem 'deviceSlots) 1)
											(cat (strCapitalize textYourShip) " does not have enough open device slots to install this device.")
											(cat (strCapitalize textYourShip) " does not have an open device slot for this device.")
											)
										))

								(eq resultCode 'reactorTooWeak)
									(setq desc (or
										(objTranslate installerObj 'rpg.cannotInstallDeviceBecauseReactorTooWeak { item:thisItem targetObj:targetObj })
										(scrTranslate gScreen 'rpg.cannotInstallDeviceBecauseReactorTooWeak { item:thisItem targetObj:targetObj })
										(cat (strCapitalize textYourShip) "'s reactor is not powerful enough for this device.")
										))

								(eq resultCode 'reactorIncompatible)
									(setq desc (or
										(objTranslate installerObj 'rpg.cannotInstallReactorBecauseTooStrong { item:thisItem targetObj:targetObj })
										(scrTranslate gScreen 'rpg.cannotInstallReactorBecauseTooStrong { item:thisItem targetObj:targetObj })
										(cat "The power output of " itemName " is too high for " textYourShip ".")
										))

								(eq resultCode 'noWeaponSlotsLeft)
									(setq desc (or
										(objTranslate installerObj 'rpg.cannotInstallDeviceBecauseLackOfWeaponSlots { item:thisItem targetObj:targetObj slotsRequired:(itmGetProperty thisItem 'deviceSlots) })
										(scrTranslate gScreen 'rpg.cannotInstallDeviceBecauseLackOfWeaponSlots { item:thisItem targetObj:targetObj slotsRequired:(itmGetProperty thisItem 'deviceSlots) })
										(if (gr (itmGetProperty thisItem 'deviceSlots) 1)
											(cat (strCapitalize textYourShip) " does not have enough open weapon slots to install this device.")
											(cat (strCapitalize textYourShip) " does not have an open weapon slot for this device.")
											)
										))

								(eq resultCode 'noNonWeaponSlotsLeft)
									(setq desc (or
										(objTranslate installerObj 'rpg.cannotInstallDeviceBecauseLackOfNonWeaponSlots { item:thisItem targetObj:targetObj slotsRequired:(itmGetProperty thisItem 'deviceSlots) })
										(scrTranslate gScreen 'rpg.cannotInstallDeviceBecauseLackOfNonWeaponSlots { item:thisItem targetObj:targetObj slotsRequired:(itmGetProperty thisItem 'deviceSlots) })
										(if (gr (itmGetProperty thisItem 'deviceSlots) 1)
											(cat (strCapitalize textYourShip) " does not have enough open non-weapon slots to install this device.")
											(cat (strCapitalize textYourShip) " does not have an open non-weapon slot for this device.")
											)
										))

								(and (eq resultCode 'replacementRequired)
										(eq (itmGetType thisItem) (itmGetType itemToReplace))
										(eq (itmGetLevel thisItem) (itmGetLevel itemToReplace))
										(eq (itmIsEnhanced thisItem) (itmIsEnhanced itemToReplace))
										(eq (itmGetProperty thisItem 'damaged) (itmGetProperty itemToReplace 'damaged))
										(geq (itmGetProperty thisItem 'charges) (itmGetProperty itemToReplace 'charges))
										)
									(setq desc (or
										(objTranslate installerObj 'rpg.cannotInstallDeviceBecauseAlreadyInstalled { item:thisItem targetObj:targetObj })
										(scrTranslate gScreen 'rpg.cannotInstallDeviceBecauseAlreadyInstalled { item:thisItem targetObj:targetObj })
										(cat (strCapitalize textYourShip) " already has " itemName " (and cannot support more devices unless you remove one first).")
										))

								(eq resultCode 'replacementRequired)
									(block Nil
										(setq desc (or
											(objTranslate installerObj 'rpg.installDeviceAfterRemove { item:thisItem targetObj:targetObj itemToReplace:itemToReplace })
											(scrTranslate gScreen 'rpg.installDeviceAfterRemove { item:thisItem targetObj:targetObj itemToReplace:itemToReplace })
											(cat (strCapitalize textWe) " can remove " textYour " " (itmGetName itemToReplace 0x80) " and install " itemName)
											))
										(setq installText 'rpg.installDeviceAfterRemove)
										(setq installTextData { item:thisItem targetObj:targetObj itemToReplace:itemToReplace })
										(setq canInstall True)
										)

								(not (eq resultCode 'ok))
									(setq desc (or
										(objTranslate installerObj 'rpg.cannotInstallDevice { item:thisItem targetObj:targetObj })
										(scrTranslate gScreen 'rpg.cannotInstallDevice { item:thisItem targetObj:targetObj })
										"This device cannot be installed."
										))

								(block Nil
									(setq desc (or
										(objTranslate installerObj 'rpg.installDevice { item:thisItem targetObj:targetObj })
										(scrTranslate gScreen 'rpg.installDevice { item:thisItem targetObj:targetObj })
										(cat (strCapitalize textWe) " can install " itemName " on " textYourShip)
										))
									(setq installText 'rpg.installDevice)
									(setq installTextData { item:thisItem targetObj:targetObj })
									(setq canInstall True)
									)
								)

							; If we need to remove a device, then it will cost more

							(setq cargoNeeded 0)
							(if (and canInstall itemToReplace)
								(block Nil
									(if (not (@ data 'totalPrice))
										(setq totalCost
											(add totalCost (objGetItemProperty installerObj itemToReplace 'removeDevicePrice))
											)
										)

									; See how much cargo space we need to store the old item

									(setq cargoNeeded (itmGetMass itemToReplace))
									(if (@ data 'itemInCargo)
										(setq cargoNeeded (subtract cargoNeeded (itmGetMass thisItem)))
										)
									)
								)

							; See if we are allowed to remove the device

							(if (and canInstall itemToReplace
									(neq (setq removeStatus (shpCanRemoveDevice targetObj itemToReplace)) 0)
									)
								(block Nil
									(setq desc (or
										(objTranslate installerObj 'rpg.cannotInstallDeviceBecauseCannotRemove { item:thisItem targetObj:targetObj itemToReplace:itemToReplace removeStatus:removeStatus })
										(scrTranslate gScreen 'rpg.cannotInstallDeviceBecauseCannotRemove { item:thisItem targetObj:targetObj itemToReplace:itemToReplace removeStatus:removeStatus })
										(cat desc ". " (if (isint removeStatus) "Unfortunately, you cannot remove the device." removeStatus))
										))
									(setq canInstall Nil)
									)
								)

							; See if the item fits

							(if (and canInstall
									(gr cargoNeeded (objGetCargoSpaceLeft targetObj))
									(not (@ data 'noCargoCheck))
									)
								(block Nil
									(setq desc (or
										(objTranslate installerObj 'rpg.cannotInstallDeviceBecauseNoRoomInCargo { item:thisItem targetObj:targetObj itemToReplace:itemToReplace removeStatus:removeStatus })
										(scrTranslate gScreen 'rpg.cannotInstallDeviceBecauseNoRoomInCargo { item:thisItem targetObj:targetObj itemToReplace:itemToReplace removeStatus:removeStatus })
										(cat desc ". Unfortunately, there isn't enough room in your cargo hold to do the swap.")
										))
									(setq canInstall Nil)
									)
								)

							; See if we can afford the installation

							(if canInstall
								(if (gr totalCost 0)
									(if (gr totalCost (objGetBalance targetObj currencyUsed))
										(block Nil
											(setq desc (or
												(objTranslate installerObj 'rpg.cannotInstallDeviceBecauseCannotAfford { item:thisItem targetObj:targetObj cost:(fmtCurrency currencyUsed totalCost) itemToReplace:itemToReplace removeStatus:removeStatus })
												(scrTranslate gScreen 'rpg.cannotInstallDeviceBecauseCannotAfford { item:thisItem targetObj:targetObj cost:(fmtCurrency currencyUsed totalCost) itemToReplace:itemToReplace removeStatus:removeStatus })
												(cat desc " for " (fmtCurrency currencyUsed totalCost) ". Unfortunately, you cannot afford the cost.")
												))
											(setq canInstall Nil)
											)
										(block (
											(advertisedCost
												(if (or (@ data 'upgrade) (@ data 'installPriceAdj))
													(fmtCurrency currencyUsed totalCost)
													(fmtCurrency currencyUsed (subtract totalCost itemPrice))
													)
												)
											)
											(setq desc (or
												(objTranslate
													installerObj
													installText
													(struct installTextData { cost:advertisedCost buyAndInstall:(@ data 'buyAndInstall) })
													)
												(scrTranslate
													gScreen
													installText
													(struct installTextData { cost:advertisedCost buyAndInstall:(@ data 'buyAndInstall) })
													)
												(cat
													desc " for " (if (@ data 'buyAndInstall) "an additional " "")
													advertisedCost
													"."
													)
												))
											)
										)

									(setq desc (or
										(objTranslate installerObj installText (struct installTextData { selfInstall:(eq installerObj gPlayerShip) }))
										(scrTranslate gScreen installText (struct installTextData { selfInstall:(eq installerObj gPlayerShip) }))
										(if (not (eq installerObj gPlayerShip))
											(cat desc " at no charge.")
											(cat desc ".")
											)
										))
									)
								)

							;	See if we are downgrading

							(if (and canInstall
									itemToReplace
									(ls (itmGetLevel thisItem) (itmGetLevel itemToReplace))
									(= (itmGetProperty thisItem 'category) (itmGetProperty itemToReplace 'category))
									(!= (itmGetProperty thisItem 'category) 'device)
									(!= (itmGetProperty thisItem 'category) 'cargoHold)
									)
								(setq descWarning (cat "Note: Your currently installed " (itmGetName itemToReplace 0x00) " is higher level."))
								)
							)

						(setq desc "You do not have any devices that can be installed.")
						)

					; Return variables
					{
						canInstall: canInstall
						price: totalCost
						desc: desc
						descWarning: descWarning
						}
					)
				))
				
			(setq rpgJettisonItem (lambda (theObj theItem)
				(block Nil
					(objAddItem theObj theItem)

					; If the player jettisoned explosive items, then mark the object
					(if (or (itmMatches theItem "mf") (itmMatches theItem "* +explosive;"))
						(objSetData theObj "PlayerExplosives" True)
						)
					)
				))

			(setq rpgPageCount (lambda (textDesc)
				(switch
					(isatom textDesc) 
						1

					(= (typeOf textDesc) 'struct)
						1
						
					(count textDesc)
					)
				))

			(setq rpgPageDesc (lambda (textDesc pageNo)
				(block (pageDesc)
					(switch
						(eq (typeof textDesc) 'struct)
							(setq pageDesc textDesc)

						(eq (typeof textDesc) 'string)
							(setq pageDesc {
								desc: textDesc
								})

						(eq (typeof (@ textDesc pageNo)) 'struct)
							(setq pageDesc (@ textDesc pageNo))

						(setq pageDesc {
							desc: (@ textDesc pageNo)
							})
						)

					(if (not (@ pageDesc 'desc))
						(set@ pageDesc 'desc "You have successfully completed the mission.")
						)

					(if (and (@ pageDesc 'nextLabel) (not (@ pageDesc 'nextKey)))
						(set@ pageDesc 'nextKey
							(@ (regex (@ pageDesc 'nextLabel) "{$?}*{{$A}+}{$?}*" 'subex) 1)
							)
						)

					pageDesc
					)
				))
				
			(setq rpgPagePaneInit (lambda (theScreen textDesc options)
			
				;	This function is used to set up a pane with the multi-page
				;	script structure.
				;
				;	textDesc is a list of page descriptors (or a plain string).
				;
				;	(scrGetData gScreen 'curPage) is the current page to display.
				;	A value of Nil means that we should show the first page.
				;
				;	The set of actions for a page is determined as follows:
				;
				;	If we're on the last page and (@ options 'onAcceptDecline) is
				;	set, then we show Accept/Decline options (we ignore any
				;	actions definitions).
				;
				;	If we have (@ pageDesc 'actions) then we create an action
				;	for each entry. The nextPage field on the action descriptor
				;	has the following possibilities:
				;
				;		'exitScreen: We unconditionally exit the screen. [Not
				;				valid if (@ options 'onExitPane) is defined.]
				;
				;		'forceUndock: We unconditionally exit the screen and
				;				for an undock. [Not valid if (@ options 'onExitPane)
				;				is defined.]
				;
				;		'missionAccept: Accept the mission.
				;
				;		'missionDecline: Decline the mission.
				;
				;		'nextPage (or Nil): We advance to the next page (by
				;				reloading the pane) or invoke the exitPane
				;				action (see below) if we're at the last page.
				;
				;		'exitPane: We either invoke the (@ options 'onExitPane)
				;				code (if any) or just exit the screen.
				;
				;		{value}: For any other value, we look up the value as
				;				an ID in textDesc. If we find it, then we
				;				navigate to that page. Otherwise, we invoke
				;				(@ options 'onNavigate) and pass in the value
				;				as a parameter.
				;
				;	We accept the following options:
				;
				;		actionDoneID: Action ID to use for the done button (defaults to
				;				'actionDone).
				;
				;		missionObj: Required if 'onAcceptDecline is defined.
				;
				;		onAcceptDecline: (lambda (theScreen acceptDecline pageDesc options) ...)
				;				This function will handle a mission accept or decline.
				;
				;		onExitPane: (lambda (theScreen pageDesc options) ...)
				;				This function is called when we continue past the last
				;				page.
				;
				;		onNavigate: (lambda (theScreen nextPage pageDesc options) ...)
				;				This function does a custom navigation.
				
				(block (
					(pageCount (rpgPageCount textDesc))
					(pageNo (if (scrGetData theScreen 'curPage) (scrGetData theScreen 'curPage) 0))
					(pageDesc (rpgPageDesc textDesc pageNo))
					
					(actions (@ pageDesc 'actions))
					(atLastPage (= pageNo (- pageCount 1)))

					(nextActionID 0)
					)
					
					;	Show the appropriate page

					(if (@ pageDesc 'textID)
						(scrSetDesc theScreen (or
							(msnTranslate (@ options 'missionObj) (@ pageDesc 'textID) (or (@ pageDesc 'data) gData))
							(scrTranslate theScreen (@ pageDesc 'textID) (or (@ pageDesc 'data) gData))
							))
						(scrSetDesc theScreen (@ pageDesc 'desc))
						)
					
					;	Make sure the actions list is properly initialized.
					
					(switch
						;	If we're on an Accept/Decline mission page but the 
						;	mission does not support declining, then we just have
						;	a single action.
						
						(and (@ options 'onAcceptDecline)
								(or atLastPage (= actions 'acceptDecline))
								(not (msnGetProperty (@ options 'missionObj) 'canBeDeclined))
								)
							(setq actions (list
								{
									label: (or 
										(scrTranslate theScreen 'actionUndock) 
										(typTranslate &dsDockScreenBase; 'actionUndock)
										)
									code: (@ pageDesc 'acceptCode)
									nextPage: 'missionAccept
									}
								))
						
						;	If we're on an Accept/Decline mission page and we're 
						;	at the last page (or if actions == 'acceptDecline), then
						;	we show Accept/Decline actions.
						
						(and (@ options 'onAcceptDecline)
								(or atLastPage (= actions 'acceptDecline))
								)
							(setq actions (list
								{
									label: (or (@ pageDesc 'acceptLabel)
										(msnTranslate (@ options 'missionObj) 'AcceptLabel)
										(typTranslate &dsDockScreenBase; 'actionAccept)
										)
									code: (@ pageDesc 'acceptCode)
									nextPage: 'missionAccept
									}
								{
									label: (or (@ pageDesc 'declineLabel)
										(msnTranslate (@ options 'missionObj) 'DeclineLabel)
										(typTranslate &dsDockScreenBase; 'actionDecline)
										)
									code: (@ pageDesc 'declineCode)
									nextPage: 'missionDecline
									}
								))
							
						;	If we don't have a list of actions, then we auto-generate 
						;	them based on variables on the page descriptor.
						
						(!= (typeof actions) 'list)
							(setq actions (list {
								label: (or 
									(@ pageDesc 'label) 
									(@ pageDesc 'nextLabel) 
									(msnTranslate (@ options 'missionObj) (@ pageDesc 'labelID))
									(scrTranslate theScreen (@ pageDesc 'labelID))
									)
								nextPage: (@ pageDesc 'nextPage)
								code: (or (@ pageDesc 'code) (@ pageDesc 'nextCode))
								}))
						)
						
					;	Initialize all actions.
					
					(enum actions actionDesc
						(block (
							(nextPage (@ actionDesc 'nextPage))
							
							(actionID (cat "action" nextActionID))
							(actionDoneID (or (@ options 'actionDoneID) 'actionDone))
							
							;	Figure out the label, if we don't have one.
							
							(actionLabel
								(switch
									(@ actionDesc 'label)
										(@ actionDesc 'label)

									(@ actionDesc 'labelID)
										(or (msnTranslate (@ options 'missionObj) (@ actionDesc 'labelID))
												(scrTranslate theScreen (@ actionDesc 'labelID))
												)
										
									;	If we're continuing, and at the last page, then we
									;	use the [D]one label.
									
									(and (or (not nextPage) (= nextPage 'nextPage))
											atLastPage
											)
										(or (scrTranslate theScreen actionDoneID) (typTranslate &dsDockScreenBase; actionDoneID))
										
									;	If we've got an explicit exit, then use the [D]one
									;	label.
									
									(or (= nextPage 'exitPane) (= nextPage 'exitScreen))
										(or (scrTranslate theScreen actionDoneID) (typTranslate &dsDockScreenBase; actionDoneID))
										
									;	If we've got an explicit undock, then use the [U]ndock
									;	label.
									
									(= nextPage 'forceUndock)
										(or (scrTranslate theScreen 'actionUndock) (typTranslate &dsDockScreenBase; 'actionUndock))
										
									;	Otherwise, we use the [C]ontinue label.
										
									(or (scrTranslate theScreen 'actionContinue) (typTranslate &dsDockScreenBase; 'actionContinue))
									)
								)
								
							;	Figure out accelerators
							
							(actionAccel
								(switch
									(eq (count actions) 1)
										(list "default" "cancel")
									(eq nextActionID 0)
										"default"
									(eq nextActionID (subtract (count actions) 1))
										"cancel"
									Nil
									)
								)
							(actionCode (@ actionDesc 'code))
							(nextPageNo Nil)
							)
							
							;	We don't support explicit exit if we've got an onExitPane
							;	option.
							
							(if (and (or (= nextPage 'exitScreen) (= nextPage 'forceUndock))
										(@ options 'onExitPane)
										)
								(setq nextPage Nil)
								)
								
							;	We don't support mission accept/decline unless we've got a
							;	mission object and onAcceptDecline.
							
							(if (and (or (= nextPage 'missionAccept) (= nextPage 'missionDecline))
										(or (not (@ options 'onAcceptDecline)) (not (@ options 'missionObj)))
										)
								(setq nextPage Nil)
								)
							
							;	Generate appropriate action
							
							(switch
								;	If we're continuing, and we're at the last page
								;	then we exit.
								
								(or (= nextPage 'exitPane)
										(and atLastPage
											(or (not nextPage) (= nextPage 'nextPage))
											)
										)
									(scrAddAction theScreen actionID Nil actionLabel Nil actionAccel
										(lambda ()
											(block Nil
												(if actionCode (actionCode))
													
												(scrSetData theScreen 'curPage Nil)
												(if (@ options 'onExitPane)
													((@ options 'onExitPane) theScreen pageDesc options)
													(scrExitScreen theScreen)
													)
												)
											)
										)
										
								;	If we're continuing, then go to the next page.
								
								(or (not nextPage) (= nextPage 'nextPage))
									(scrAddAction theScreen actionID Nil actionLabel Nil actionAccel
										(lambda ()
											(block Nil
												(if actionCode (actionCode))
													
												(scrSetData theScreen 'curPage (+ pageNo 1))
												(scrShowPane theScreen (@ (scrGetScreen theScreen) 'pane))
												)
											)
										)
								
								(= nextPage 'exitScreen)
									(scrAddAction theScreen actionID Nil actionLabel Nil actionAccel
										(lambda ()
											(block Nil
												(if actionCode (actionCode))
													
												(scrExitScreen theScreen)
												)
											)
										)
								
								(= nextPage 'forceUndock)
									(scrAddAction theScreen actionID Nil actionLabel Nil actionAccel
										(lambda ()
											(block Nil
												(if actionCode (actionCode))
													
												(scrExitScreen theScreen 'forceUndock)
												)
											)
										)
									
								(= nextPage 'missionAccept)
									(scrAddAction theScreen actionID Nil actionLabel Nil actionAccel
										(lambda ()
											(block Nil
												(if actionCode (actionCode))
													
												((@ options 'onAcceptDecline) theScreen 'accept pageDesc options)
												)
											)
										)
								
								(= nextPage 'missionDecline)
									(scrAddAction theScreen actionID Nil actionLabel Nil actionAccel
										(lambda ()
											(block Nil
												(if actionCode (actionCode))
													
												((@ options 'onAcceptDecline) theScreen 'decline pageDesc options)
												)
											)
										)
										
								;	If we have a new page number by ID, then navigate to it.
								
								(setq nextPageNo (rpgFindIndexByID textDesc nextPage))
									(scrAddAction theScreen actionID Nil actionLabel Nil actionAccel
										(lambda ()
											(block Nil
												(if actionCode (actionCode))
													
												(scrSetData theScreen 'curPage nextPageNo)
												(scrShowPane theScreen (@ (scrGetScreen theScreen) 'pane))
												)
											)
										)
								
								;	If we have onNavigate, invoke that
								
								(@ options 'onNavigate)
									(scrAddAction theScreen actionID Nil actionLabel Nil actionAccel
										(lambda ()
											(block Nil
												(if actionCode (actionCode))
													
												((@ options 'onNavigate) theScreen nextPage pageDesc options)
												)
											)
										)
								)
							
							;	Next action ID
											
							(setq nextActionID (add nextActionID 1))
							)
						)
					)
				))

			(setq rpgRestorePlayer (lambda ()

			; Repairs and restores the player's ship and places it at a random, safe
			; position in the system.

				(block (portObj newPos)

					; Find the nearest friendly station in the system
					(setq portObj (sysFindObject gPlayerShip "TAFN +populated; -occupation;"))
					(if (not portObj)
						(enumwhile (sysFindObject gPlayerShip "tF") (not portObj) theObj
							(if (not (sysFindObject theObj "sTEN:75"))
								(setq portObj theObj)
								)
							)
						)
					(if (not portObj)
						(setq portObj (sysFindObject gPlayerShip "tFN"))
						)

					; Pick a random position
					(setq newPos (sysVectorRandom portObj (random 30 40) 10 "t"))

					; Place the ship there
					(objMoveTo gPlayerShip newPos)

					; Repair the ship
					(intArmorRepairAll gPlayerShip 25 'alwaysRepair)
					(intDeviceRepairAll gPlayerShip)
					(shpRechargeShield gPlayerShip 1000)
					(shpRefuelFromItem gPlayerShip (itmCreate &itHelium3FuelRod; (shpGetFuelNeeded gPlayerShip (itmCreate &itHelium3FuelRod; 1))))
					(objChangeEquipmentStatus gPlayerShip 'SRS 'repair)
					(objFixParalysis gPlayerShip)
					(shpDecontaminate gPlayerShip)
					
					(objSetProperty gPlayerShip 'interiorHP (objGetProperty gPlayerShip 'maxInteriorHP))
					
					; Remove any overlays that shouldn't be there (e.g., pteravores)
					(enum (objGetOverlays gPlayerShip) theOverlay
						(objFireOverlayEvent gPlayerShip theOverlay "OnInsuranceClaim")
						)
					)
				))
				
			(setq rpgSelectorInitialItem (lambda (criteria)
                (block (
                
				    ;	deviceSelected is a struct with one of the following fields:
				    ;		slotPosIndex: This means we should select a slot of 
				    ;			this index.
				    ;		installPos: This means we should select a device in this
				    ;			install position.
				    ;		installCategory: This means we should select a device 
				    ;			with this category (or an empty slot with this
				    ;			category).
				    ;		oldSlots: This means that we select the item that was
				    ;			most recently installed (and thus is NOT on this list
				    ;			of old devices).
				
				    (deviceSelected (scrGetData gScreen 'deviceSelected))
				
				    ;	If none of the player's devices are installed in one of the
				    ;	oldSlots, then it means that we cancelled installation/upgrade
				
				    (cancelled 
					    (and (@ deviceSelected 'oldSlots)
						    (not (filter (objGetItems gPlayerShip criteria) theItem
							    (not (find (@ deviceSelected 'oldSlots) (itmGetInstallPos theItem)))
							    ))
						    )
					    )
				    )
				
				    (switch
					    (not deviceSelected)
						    True
						
					    (and (not cancelled) (@ deviceSelected 'oldSlots))
						    (and (scrGetItem gScreen) 
							    (not (find (@ deviceSelected 'oldSlots) (itmGetInstallPos (scrGetItem gScreen))))
							    )
							
					    (@ deviceSelected 'slotPosIndex)
						    (eq (@ deviceSelected 'slotPosIndex) (if (not (scrGetItem gScreen)) (@ (scrGetListEntry gScreen) 'slotPosIndex)))
						
					    (@ deviceSelected 'installPos)
						    (eq (@ deviceSelected 'installPos) (if (scrGetItem gScreen) (itmGetInstallPos (scrGetItem gScreen))))
						
					    (@ deviceSelected 'installCategory)
						    (eq (@ deviceSelected 'installCategory) (if (scrGetItem gScreen) (itmGetProperty (scrGetItem gScreen) 'category) (@ (scrGetListEntry gScreen) 'category)))
						
					    True
					    )
				    )            
                ))
			)
	</Globals>

</TranscendenceModule>